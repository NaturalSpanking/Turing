#pragma hdrstop

#include "Machine.h"

Machine::Machine() {}

Machine* Machine::mach = NULL;

//Создание машины с параметрами таблицы и ленты заданными в параметрах
Machine* Machine::Create(unsigned tapLen, unsigned tabRows, unsigned tabCol)
{
	if (mach != NULL) return mach;
	mach = new Machine();
	mach->tab = new Table(tabRows, tabCol);
	mach->tap = new Tape(tapLen);
	mach->currentState = 1;
	mach->tapMem = NULL;
	mach->tapMemSys = NULL;
	return mach;
}
//Деструктор
Machine::~Machine()
{
	if (mach == NULL) return;
	delete mach->tab;
	delete mach->tap;
	mach = NULL;
}
//Шаг машины
//Возвращаемые значения:
//-4 - состояние в которое нужно перейти не существует
//-3 - символ в ленте или символ в таблице не существует в алфавите
//-2 - машина перешла в незаполенную ячейку таблицы
//-1 - не удалось получить символ из ленты(выход за границы ленты)
// 0 - шаг успешно завершен
// 1 - шаг успешно завершен с переходом машины в 0-е состояние(окончание программы)
// 2 - шаг успешно завершен, следующая ячейка - точка останова
int Machine::Step()
{
	rule errRule;
	WideChar tempChar = GetTapeChar(GetTapePosition());
	if (tempChar == '\0') return -1;
	if (!InAlphabet(tempChar)) return -3;
	rule tempRule = GetTableRule(currentState, tempChar);
	if (tempRule == errRule)
	{
		currentState = 1;
		return -2;
	}
	if (!InAlphabet(tempRule.symbol)) return -3;
	if (tempRule.new_state < 0 || tempRule.new_state > (int)tab->table[0].size()) return -4;

	SetTapeChar(GetTapePosition(), tempRule.symbol);
	ShiftTape(tempRule.shift);
	currentState = tempRule.new_state;
	if (currentState == 0)
	{
		currentState = 1;
		return 1;
	}
	if(IsBreakepoint(tempRule.symbol, tempRule.new_state) == 1) return 2;
	else return 0;
}

/*int Machine::TraceProgram()
{
	while (true)
	{
		rule errRule;
		WideChar tempChar = GetTapeChar(GetTapePosition());
		if (tempChar == '\0') return -1;
		rule tempRule = GetTableRule(currentState, tempChar);
		if (tempRule == errRule)
		{
			currentState = 1;
			return -2;
		}

		if (tempRule.is_breakpoint == 1) return 0;

		SetTapeChar(GetTapePosition(), tempRule.symbol);
		ShiftTape(tempRule.shift);
		currentState = tempRule.new_state;
		if (currentState == 0)
		{
			currentState = 1;
			return 1;
		}
	}
}*/
//Установка начального состояния в машине
void Machine::SetInitialState()
{
	currentState = 1;
}
//Сохранение программы(лента + таблица) в файл
//Возвращаемые значения:
//-1 - не удалось открыть файл для записи
// 0 - сохранение успешно
int Machine::SaveProgram(UnicodeString pathToFile)
{
	std::ofstream file;
	unsigned Rows = tab->table.size();
	unsigned Columns = tab->table[0].size();
	AnsiString A;
	A=pathToFile;
	file.open(A.c_str());
	if (!file.is_open()) return -1;

	file << tap->tape.size() << " " << Rows << " " << Columns << "\n";

	//Запись ленты
	for (unsigned i = 0; i < tap->tape.size(); i++)
	{
		file << tap->tape[i];
		file << " ";
	}
	file << "\n";

	//запись таблицы
	for (unsigned i = 0; i < Rows; i++)
	{
		for (unsigned ii = 0; ii < Columns; ii++)
		{
			if (ii != 0)
			{
				if (tab->table[i][ii].symbol != ' ') file << tab->table[i][ii].symbol;
				else file << " ";
				if (tab->table[i][ii].shift != -2)
				{
					if (tab->table[i][ii].shift == 1) file << ">";
					if (tab->table[i][ii].shift == -1) file << "<";
					if (tab->table[i][ii].shift == 0) file << ".";
				}
				else file << " ";
				if (tab->table[i][ii].new_state != -1) file << tab->table[i][ii].new_state;
				else file << " ";
			}
			else
			{
				file << tab->table[i][ii].symbol;
			}
			if (ii+1 < Columns) file << " ";
		}
		file << "\n";
	}

	file.close();
	return 0;
}
//Загрузка программы(лента + таблица) в файл
//Возвращаемые значения:
//-3 - таблица не может существовать
//-2 - BadFile
//-1 - не удалось открыть файл для чтения
// 0 - сохранение успешно
int Machine::LoadProgram(UnicodeString pathToFile){
	std::ifstream file;
	AnsiString A;
	A=pathToFile;
	file.open(A.c_str());
	if (!file.is_open()) return -1;
	//1 - tapLen
	//2 - Rows
	//3 - Columns
	unsigned params[3] = {0};
	char buff[BUFF_SIZE];

	//Получение параметров ленты и таблицы
	for (int i = 0; i < 3; i++){
		if (!file.good()) return -2;
		file >> buff;
		params[i] = atoi(buff);
		if (params[i] <= 0) return -2;
	}

	//Установка параметров и очистка старых
	tap->tape.resize(params[0], ' ');

	rule defRule;
	tab->table.resize(params[1]);
	for (unsigned i = 0; i < params[1]; i++){
		tab->table[i].resize(params[2], defRule);
	}

	//Получение ленты
	file.ignore();
	if (!file.good()) return -2;
//	file.getline(buff, BUFF_SIZE);
//	if (strlen(buff) != params[0]) return -2;
	for (unsigned i = 0; i < params[0]; i++)
	{
		file >> buff;
		file.ignore();
		tap->tape[i] = atoi(buff);
	}

	//Получение таблицы
	int intTemp;
	for (unsigned i = 0; i < params[1]; i++)
	{
		if (!file.good()) return -2;
		for (unsigned ii = 0; ii < params[2]; ii++)
		{
			if (!file.good()) return -2;
			if (ii != 0)
			{
				int counter = 0;
				while(file.peek() != ' ' || file.peek() != '>' || file.peek() != '<' || file.peek() != '.')
				{
					file.read(buff+counter, 1);
					counter++;
				}
				tab->table[i][ii].symbol = atoi(buff);

				buff[0] = '\0';
				buff[1] = '\0';
				file.read(buff, 1);
				if (buff[0] != '>' && buff[0] != '<' && buff[0] != '.' && buff[0] != ' ') return -2;
				if (buff[0] == '>') tab->table[i][ii].shift = 1;
				if (buff[0] == '<') tab->table[i][ii].shift = -1;
				if (buff[0] == '.') tab->table[i][ii].shift = 0;
				if (buff[0] == ' ') tab->table[i][ii].shift = -2;

				if (file.peek() == ' ')
				{
					file.ignore();
					intTemp = -1;
				}
				else
				{
					file >> buff;
					intTemp = atoi(buff);
					if (intTemp < 0) return -2;
				}
				tab->table[i][ii].new_state = intTemp;

				tab->table[i][ii].is_breakpoint = 0;

				if (ii + 1 == params[2] && file.peek() != '\n') return -2;
				else file.ignore();
			}
			else
			{
				buff[0] = '\0';
				buff[1] = '\0';
				file.read(buff, 1);
				file.ignore();
				if (buff[0] == '\n' || buff[0] == '\0') return -2;
				tab->table[i][ii].symbol = buff[0];
			}
		}
	}
	if (CheckTable() == -1){
		for (unsigned i = 0; i < tab->table.size(); i++)
		{
			for (unsigned ii = 1; ii < tab->table.size(); ii++)
			{
				tab->table[i][ii] = defRule;
			}
		}
		return -3;
	}

	file.close();
	return 0;
}
//Сохранение ленты в временное хранилище
//isUser == U - сохранение в пользовательское хранилище
//isUser != U - сохранение в системное хранилище
void Machine::SaveTape(WideChar isUser)
{
	if (isUser == 'U') tapMem = tap->CreateMemento();
	else tapMemSys = tap->CreateMemento();
}
//isUser == U - загрузка из пользовательского хранилищеа
//isUser != U - загрузка из системного хранилищеа
//Возвращаемые значения:
//-1 - не найдено хранилище(лента не разу не сохранена)
// 0 - загрузка успешна
int Machine::LoadTape(WideChar isUser)
{
	if (isUser == 'U') {
		if (tapMem == NULL) return -1;
		tap->SetMemento(tapMem);
		return 0;
	}
	else
	{
		if (tapMemSys == NULL) return -1;
		tap->SetMemento(tapMemSys);
		return 0;
	}
}
//Проверка корректности таблицы
//Возвращаемые значения:
//-1 - проверка не пройдена
// 0 - проверка пойдена
int Machine::CheckTable()
{
	for (unsigned i = 0; i < tab->table.size(); i++)
	{
		for (unsigned ii = 1; ii < tab->table[0].size(); ii++)
		{
			if (!InAlphabet(tab->table[i][ii].symbol)) return -1;
		}
	}
	return 0;
}
//Получение правила из ячейки
//Возвращаемые значения:
//errRule - такой ячейки не существует
rule Machine::GetTableRule(unsigned state, WideChar c)
{
	rule errRule;
	if (tab->table.size() == 0) return errRule;
	if (state > tab->table[0].size()) return errRule;

	for (unsigned i = 0; i < tab->table.size(); i++)
	{
		if (tab->table[i][0].symbol == c) return tab->table[i][state];
	}

	return errRule;
}
//Установка правила в ячейку таблицы
//Возвращаемые значения:
//-1 - такой ячейки нет\таблица пуста
// 0 - успешно установлено
int Machine::SetTableRule(unsigned state, WideChar c, rule r)
{
	if (state > tab->table[0].size()) return -1;

	for (unsigned i = 0; i < tab->table.size(); i++)
	{
		if (tab->table[i][0].symbol == c){
			tab->table[i][state] = r;
			return 0;
		}
	}

	return -1;
}
//Получение текущего состояния машины
int Machine::GetCurrentState()
{
	return currentState;
}
//Проверка ячейки на наличие точки останова
//Возвращаемые значения:
// -1 - такой ячейки нет\таблица пуста
//0\1 - получено наличие\отсутствие точки останова
int Machine::IsBreakepoint(unsigned state, WideChar c)
{
	if (state > tab->table[0].size()) return -1;

	for (unsigned i = 0; i < tab->table.size(); i++)
	{
		if (tab->table[i][0].symbol == c && tab->table[i][state].is_breakpoint == 1) return 1;
	}
	return 0;
}
//Проверка наличия символа в алфавите
//Возвращаемые значения:
//0 - такого символа нет
//1 - такой символ есть
bool Machine::InAlphabet(WideChar c)
{
	for (unsigned i = 0; i < tab->table.size(); i++)
	{
		if (tab->table[i][0].symbol == c) return 1;
	}
	return 0;
}
//Получение значения символа 1-го столбца(символы алфавита) по его индексу
WideChar Machine::GetAlphabet(int index){
	if (tab->table.size() == 0) return 0;
	if (index >(int)tab->table.size()) return 0;
	return tab->table[index][0].symbol;
}
//Установка значения ячейки в ленте по индексу
//Возвращаемые значения:
//-1 - выход за пределы ленты
// 0 - успешно установлено
int Machine::SetTapeChar(unsigned index, WideChar c)
{
	if (index >= tap->tape.size()) return -1;
	tap->tape[index] = c;
	return 0;
}
//Установка положения пишущей головки в ленте
//Возвращаемые значения:
//-1 - выход за пределы ленты
// 0 - успешно установлено
int Machine::SetTapePosition(unsigned position)
{
	if (position >= tap->tape.size()) return -1;
	tap->position = position;
	return 0;
}
//Сдвиг положения пишущей головки в ленте
//Возвращаемые значения:
//-1 - выход за пределы ленты
// 0 - успешно установлено
int Machine::ShiftTape(int shift)
{
	if ((int)tap->position + shift > (int)tap->tape.size() && shift > 0) return -1;
	if (shift == 0) return 0;
	if ((int)tap->position + shift < 0 && shift < 0) return -1;
	tap->position += shift;
	return 0;
}
//Получение значение ячейки ленты по индексу
//Возвращаемые значения:
//'\0' - выход за пределы ленты
WideChar Machine::GetTapeChar(unsigned index)
{
	if (index >= tap->tape.size()) return '\0';
	return tap->tape[index];
}
//Получение текущего положения пишущей головки в ленте
int Machine::GetTapePosition()
{
	return tap->position;
}

#pragma package(smart_init)
