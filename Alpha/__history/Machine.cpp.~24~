#pragma hdrstop

#include "Machine.h"

Machine::Machine() {}

Machine* Machine::mach = NULL;

//Создание машины с параметрами таблицы и ленты заданными в параметрах
Machine* Machine::Create(unsigned tapLen, unsigned tabRows, unsigned tabCol)
{
	if (mach != NULL) return mach;
	mach = new Machine();
	mach->tab = new Table(tabRows, tabCol);
	mach->tap = new Tape(tapLen);
	mach->currentState = 1;
	mach->tapMem = NULL;
	mach->tapMemSys = NULL;
	return mach;
}
//Деструктор
Machine::~Machine()
{
	if (mach == NULL) return;
	delete mach->tab;
	delete mach->tap;
	mach = NULL;
}
//Шаг машины
//Возвращаемые значения:
//-2 - Машина перешла в незаполенную ячейку таблицы
//-1 - Не удалось получить символ из ленты(выход за границы ленты)
// 0 - Шаг успешно завершен
// 1 - Шаг успешно завершен с переходом машины в 0-е состояние(окончание программы)
// 2 - Шаг успешно завершен с выходом на ячейке с точкой останова
int Machine::Step()
{
	rule errRule;
	WideChar tempChar = GetTapeChar(GetTapePosition());
	if (tempChar == '\0') return -1;
	rule tempRule = GetTableRule(currentState, tempChar);
	if (tempRule == errRule)
	{
		currentState = 1;
		return -2;
	}

	SetTapeChar(GetTapePosition(), tempRule.symbol);
	ShiftTape(tempRule.shift);
	currentState = tempRule.new_state;
	if (currentState == 0)
	{
		currentState = 1;
		return 1;
	}
	if(tempRule.is_breakpoint == 0) return 0;
	else return 2;
}

/*int Machine::TraceProgram()
{
	while (true)
	{
		rule errRule;
		WideChar tempChar = GetTapeChar(GetTapePosition());
		if (tempChar == '\0') return -1;
		rule tempRule = GetTableRule(currentState, tempChar);
		if (tempRule == errRule)
		{
			currentState = 1;
			return -2;
		}

		if (tempRule.is_breakpoint == 1) return 0;

		SetTapeChar(GetTapePosition(), tempRule.symbol);
		ShiftTape(tempRule.shift);
		currentState = tempRule.new_state;
		if (currentState == 0)
		{
			currentState = 1;
			return 1;
		}
	}
}*/
//Установка начального состояния в машине
int Machine::SetInitialState()
{
	currentState = 1;
}

//int Machine::SaveProgram(char* pathToFile);
//int Machine::LoadProgram(char* pathToFile);

//Сохранение ленты в временное хранилище
//isUser == U - сохранение в пользовательское хранилище
//isUser != U - сохранение в системное хранилище
void Machine::SaveTape(WideChar isUser)
{
	if (isUser == 'U') tapMem = tap->CreateMemento();
	else tapMemSys = tap->CreateMemento();
}
//isUser == U - загрузка из пользовательского хранилищеа
//isUser != U - загрузка из системного хранилищеа
//Возвращаемые значения:
//-1 - не найдено хранилище(лента не разу не сохранена)
// 0 - загрузка успешна
int Machine::LoadTape(WideChar isUser)
{
	if (isUser == 'U') {
		if (tapMem == NULL) return -1;
		tap->SetMemento(tapMem);
		return 0;
	}
	else
	{
		if (tapMemSys == NULL) return -1;
		tap->SetMemento(tapMemSys);
		return 0;
	}
}
//Проверка ячейки на наличие точки останова
//Возвращаемые значения:
// -1 - такой ячейки нет\таблица пуста
//0\1 - получено наличие\отсутствие точки останова
int Machine::IsBreakepoint(unsigned state, WideChar c)
{
	if (tab->table.size() == 0) return -1;
	if (state > tab->table[0].size()) return -1;

	for (unsigned i = 0; i < tab->table.size(); i++)
	{
		if (tab->table[i][0].symbol == c && tab->table[i][state].is_breakpoint == 1) return 1;
	}
	return 0;
}

WideChar Machine::GetAlphabet(int index){
	if (tab->table.size() == 0) return 0;
	if (index > tab->table.size()) return 0;
	return tab->table[index][0].symbol;
}
//Получение правила из ячейки
//Возвращаемые значения:
//errRule - такой ячейки не существует
rule Machine::GetTableRule(unsigned state, WideChar c)
{
	rule errRule;
	if (tab->table.size() == 0) return errRule;
	if (state > tab->table[0].size()) return errRule;

	for (unsigned i = 0; i < tab->table.size(); i++)
	{
		if (tab->table[i][0].symbol == c) return tab->table[i][state];
	}

	return errRule;
}
//Установка правила в ячейку таблицы
//Возвращаемые значения:
//-1 - такой ячейки нет\таблица пуста
// 0 - успешно установлено
int Machine::SetTableRule(unsigned state, WideChar c, rule r)
{

	if (tab->table.size() == 0) return -1;
	if (state > tab->table[0].size()) return -1;

	for (unsigned i = 0; i < tab->table.size(); i++)
	{
		if (tab->table[i][0].symbol == c){
			tab->table[i][state] = r;
			return 0;
		}
	}

	return -1;
}
//Получение текущего состояния машины
int Machine::GetCurrentState()
{
	return currentState;
}
//Установка значения ячейки в ленте по индексу
//Возвращаемые значения:
//-1 - выход за пределы ленты
// 0 - успешно установлено
int Machine::SetTapeChar(unsigned index, WideChar c)
{
	if (index >= tap->tape.size()) return -1;
	tap->tape[index] = c;
	return 0;
}
//Установка положения пишущей головки в ленте
//Возвращаемые значения:
//-1 - выход за пределы ленты
// 0 - успешно установлено
int Machine::SetTapePosition(unsigned position)
{
	if (position >= tap->tape.size()) return -1;
	tap->position = position;
	return 0;
}
//Сдвиг положения пишущей головки в ленте
//Возвращаемые значения:
//-1 - выход за пределы ленты
// 0 - успешно установлено
int Machine::ShiftTape(int shift)
{
	if ((int)tap->position + shift > tap->tape.size() && shift > 0) return -1;
	if (shift == 0) return 0;
	if ((int)tap->position + shift < 0 && shift < 0) return -1;
	tap->position += shift;
	return 0;
}
//Получение значение ячейки ленты по индексу
//Возвращаемые значения:
//'\0' - выход за пределы ленты
WideChar Machine::GetTapeChar(unsigned index)
{
	if (index >= tap->tape.size()) return '\0';
	return tap->tape[index];
}
//Получение текущего положения пишущей головки в ленте
int Machine::GetTapePosition()
{
	return tap->position;
}

#pragma package(smart_init)
